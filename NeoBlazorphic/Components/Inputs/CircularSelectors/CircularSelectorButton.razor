@using NeoBlazorphic.Math.Units
@using NeoBlazorphic.StyleParameters
@using NeoBlazorphic.UserInteraction.Mouse.BaseComponents
@using NeoBlazorphic.Extensions.BaseTypes
@using NeoBlazorphic.Models.SelectableItems

@typeparam T

@inherits MouseInteractiveBaseComponent

@{

    // calculate origins for gradients since we want the gradient to invert the rotation of the button itself
    // we take base angle as 135 deg
    var angleInRadiansForGradient = Converter.ToRadian(AngleShift + 135);

    // The 20 comes from the radius of the bigger circle of the selector, radius which we need to inject into the trigonometric calculations
    var originX = (Math.Cos(angleInRadiansForGradient) * 20).ToInvariantString();
    var originY = (-Math.Sin(angleInRadiansForGradient) * 20).ToInvariantString();
    var endX = (-Math.Cos(angleInRadiansForGradient) * 20).ToInvariantString();
    var endY = (Math.Sin(angleInRadiansForGradient) * 20).ToInvariantString();

    // calculate label position
    var angleInRadians = Converter.ToRadian(ButtonAngle); 

    // Since the radius is 20 but we don't want to place the label on the circle, we use a smaller radius for trigonometric calculations
    var labelX = (Math.Cos(angleInRadians / 2) * 15).ToInvariantString();
    var labelY = (-(Math.Sin(angleInRadians / 2) * 15)).ToInvariantString();
}

<g class="@($"{(Item.IsEnabled ? "" : "neo-disabled")}")" style="transition: all .15s ease-in-out;" transform="rotate(@($"{AngleShift}")) scale(@_scaleFactor)">
    <defs>
        <!-- Gradient for the button, we use the calculated origin to act as if all buttons where sharing the same gradient -->
        <linearGradient id=@($"{UID}-ButtonGradient") x1=@originX y1=@originY x2=@endX y2=@endY gradientUnits="userSpaceOnUse">
            @if (Shape == BackgroundShape.Concave)
            {
                <stop offset="0%" stop-color="var(--dark-color)"/>
                <stop offset="100%" stop-color="var(--light-color)"/>
            }
            else if (Shape == BackgroundShape.Convex)
            {
                <stop offset="0%" stop-color="var(--light-color)"/>
                <stop offset="100%" stop-color="var(--dark-color)"/>
            }
        </linearGradient>
    </defs>
    
    <!-- Drawing the button itself -->
    <path d=@PathString fill="url(@($"#{UID}-ButtonGradient"))"
          @onmouseover=OnMouseOver @onmouseout=OnMouseOut @onmousedown=OnMouseDown @onmouseup=OnMouseUp @onclick=OnMouseClick>
    </path>
    
    <!-- Using the index as the displayed property -->
    <text text-anchor="middle" x=@labelX y=@labelY
          style="fill: var(--text-color); stroke-width: 0px; font: normal 4px Verdana, Helvetica, Arial, sans-serif; pointer-events: none;" transform="rotate(@($"{-AngleShift}") @labelX @labelY)">
        @Item.Label
    </text>
</g>

@if (Item != SelectableItem<T>.Empty && Item.IsEnabled)
{

    <g class=@AccentClass style="transition: all .15s ease-in-out, opacity 0.2s ease-in-out; opacity: @(Item.IsSelected ? "1" : "0")" transform="rotate(@($"{AngleShift}")) scale(@_scaleFactor)">
        <defs>
            <!-- Gradient for the button, we use the calculated origin to act as if all buttons where sharing the same gradient -->
            <linearGradient id=@($"{UID}-ButtonGradient2") x1=@originX y1=@originY x2=@endX y2=@endY gradientUnits="userSpaceOnUse">
                @if (Shape == BackgroundShape.Concave)
                {
                    <stop offset="0%" stop-color="var(--dark-color)"/>
                    <stop offset="100%" stop-color="var(--light-color)"/>
                }
                else if (Shape == BackgroundShape.Convex)
                {
                    <stop offset="0%" stop-color="var(--light-color)"/>
                    <stop offset="100%" stop-color="var(--dark-color)"/>
                }
            </linearGradient>
        </defs>

        <!-- Drawing the button itself -->
        <path d=@PathString fill="url(@($"#{UID}-ButtonGradient2"))"
              @onmouseover=OnMouseOver @onmouseout=OnMouseOut @onmousedown=OnMouseDown @onmouseup=OnMouseUp @onclick=OnMouseClick>
        </path>

        <!-- Using the index as the displayed property -->
        <text text-anchor="middle" x=@labelX y=@labelY
              style="fill: var(--text-color); stroke-width: 0px; font: normal 4px Verdana, Helvetica, Arial, sans-serif; pointer-events: none;" transform="rotate(@($"{-AngleShift}") @labelX @labelY)">
            @Item.Label
        </text>
    </g>
}
